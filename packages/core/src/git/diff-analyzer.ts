import type { CommitInfo, CommitDiff, FileDiff, FileStatus, DiffStats } from '../types/git.js';
import type { AnalysisConfig } from '../types/config.js';
import { Repository } from './repository.js';

const LOCK_FILE_PATTERNS = [
  /package-lock\.json$/,
  /pnpm-lock\.yaml$/,
  /yarn\.lock$/,
  /Cargo\.lock$/,
  /Gemfile\.lock$/,
  /poetry\.lock$/,
  /composer\.lock$/,
  /go\.sum$/,
];

const AUTO_GENERATED_PATTERNS = [
  /\.min\.(js|css)$/,
  /\.generated\./,
  /\.g\.(dart|cs)$/,
  /\/dist\//,
  /\/build\//,
  /\.pb\.go$/,
  /\.swagger\./,
];

export async function analyzeDiff(
  repo: Repository,
  commit: CommitInfo,
  config: AnalysisConfig,
): Promise<CommitDiff> {
  let rawDiff: string;
  try {
    rawDiff = await repo.getDiff(commit.hash);
  } catch {
    rawDiff = await repo.getDiffForFirstCommit(commit.hash);
  }

  const files = parseDiffContent(rawDiff, config);
  const stats = computeStats(files);

  return {
    commit,
    files,
    stats,
  };
}

function parseDiffContent(rawDiff: string, config: AnalysisConfig): FileDiff[] {
  const files: FileDiff[] = [];
  const fileSections = rawDiff.split(/^diff --git /m).filter(Boolean);

  for (const section of fileSections) {
    const lines = section.split('\n');
    const headerLine = lines[0] ?? '';

    const pathMatch = headerLine.match(/a\/(.+?) b\/(.+)/);
    if (!pathMatch) continue;

    const oldPath = pathMatch[1];
    const newPath = pathMatch[2];
    const path = newPath ?? oldPath ?? 'unknown';

    if (config.skipLockFiles && isLockFile(path)) continue;
    if (config.skipAutoGenerated && isAutoGenerated(path)) continue;

    const isBinary = section.includes('Binary files');
    const status = detectFileStatus(section);

    let additions = 0;
    let deletions = 0;
    const contentLines: string[] = [];

    for (const line of lines) {
      if (line.startsWith('+') && !line.startsWith('+++')) {
        additions++;
        contentLines.push(line);
      } else if (line.startsWith('-') && !line.startsWith('---')) {
        deletions++;
        contentLines.push(line);
      } else if (line.startsWith('@@') || line.startsWith(' ')) {
        contentLines.push(line);
      }
    }

    files.push({
      path,
      oldPath: oldPath !== newPath ? oldPath : undefined,
      status,
      additions,
      deletions,
      content: contentLines.join('\n'),
      isBinary,
    });
  }

  return files;
}

function detectFileStatus(section: string): FileStatus {
  if (section.includes('new file mode')) return 'added';
  if (section.includes('deleted file mode')) return 'deleted';
  if (section.includes('rename from')) return 'renamed';
  if (section.includes('copy from')) return 'copied';
  return 'modified';
}

function computeStats(files: FileDiff[]): DiffStats {
  let totalAdditions = 0;
  let totalDeletions = 0;

  for (const file of files) {
    totalAdditions += file.additions;
    totalDeletions += file.deletions;
  }

  return {
    totalFiles: files.length,
    totalAdditions,
    totalDeletions,
    effectiveChanges: totalAdditions + totalDeletions,
  };
}

function isLockFile(path: string): boolean {
  return LOCK_FILE_PATTERNS.some((p) => p.test(path));
}

function isAutoGenerated(path: string): boolean {
  return AUTO_GENERATED_PATTERNS.some((p) => p.test(path));
}
